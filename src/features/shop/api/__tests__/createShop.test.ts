import { createShop } from "@/features/shop/api/createShop";
import { supabase } from "@/lib/supabase";
import { beforeEach, describe, expect, it, vi } from "vitest";

vi.mock("@/lib/supabase", () => {
  return {
    supabase: {
      from: vi.fn(),
    },
  };
});

describe("createShop", () => {
  const mockInsert = vi.fn();
  const mockSelect = vi.fn();
  const mockSingle = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();

    // We configure the method "chain" of supabase
    (supabase.from as any).mockReturnValue({
      insert: mockInsert.mockReturnValue({
        select: mockSelect.mockReturnValue({
          single: mockSingle,
        }),
      }),
    });
  });

  it("return the complete Shop generated by Supabase", async () => {
    const now = new Date();
    const fakeResponse = {
      id: "abc-123", // generated by Supabase
      group_id: null,
      name: "Test Shop",
      address: "Cupertino",
      phone: "0612345678",
      created_at: now.toISOString(),
    };

    mockSingle.mockResolvedValueOnce({ data: fakeResponse, error: null });

    const result = await createShop({
      name: "Test Shop",
      address: "Cupertino",
      phone: "0612345678",
    });

    expect(supabase.from).toHaveBeenCalledWith("shops");
    expect(mockInsert).toHaveBeenCalledWith([
      expect.objectContaining({
        name: "Test Shop",
        address: "Cupertino",
        phone: "0612345678",
      }),
    ]);

    // Transformed result
    expect(result).toEqual({
      id: fakeResponse.id,
      groupID: fakeResponse.group_id,
      name: fakeResponse.name,
      address: fakeResponse.address,
      phone: fakeResponse.phone,
      createdAt: new Date(fakeResponse.created_at),
    });
  });

  it("throws an error", async () => {
    mockSingle.mockResolvedValueOnce({
      data: null,
      error: new Error("DB error"),
    });

    await expect(
      createShop({ name: "Error", address: "No addres" })
    ).rejects.toThrow("Erreur lors de la cr√©ation du magasin");
  });
});
