import { createShopCode } from "@/features/shopCode/api/createShopCode";
import { supabase } from "@/lib/supabase";
import { beforeEach, describe, expect, it, vi } from "vitest";

vi.mock("@/lib/supabase", () => {
  return {
    supabase: {
      from: vi.fn(),
    },
  };
});

describe("createShopCode", () => {
  const mockInsert = vi.fn();
  const mockSelect = vi.fn();
  const mockSingle = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();

    // We configure the method "chain" of supabase
    (supabase.from as any).mockReturnValue({
      insert: mockInsert.mockReturnValue({
        select: mockSelect.mockReturnValue({
          single: mockSingle,
        }),
      }),
    });
  });

  it("return the complete ShopCode generated by Supabase", async () => {
    const now = new Date();
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 1);

    const fakeResponse = {
      id: "abc-123", // generated by Supabase
      code: "XYZ999", // generated by Supabase
      shop_id: "456",
      is_used: false,
      expires_at: expiresAt,
      created_at: now.toISOString(),
    };

    mockSingle.mockResolvedValueOnce({ data: fakeResponse, error: null });

    const result = await createShopCode({ shopID: "456" });

    expect(supabase.from).toHaveBeenCalledWith("shop_codes");
    expect(mockInsert).toHaveBeenCalledWith([
      expect.objectContaining({
        shop_id: "456",
        expires_at: expect.any(Date),
      }),
    ]);

    // Transformed result
    expect(result).toEqual({
      id: "abc-123",
      code: "XYZ999",
      shopID: "456",
      isUsed: false,
      expiresAt: new Date(fakeResponse.expires_at),
      createdAt: new Date(fakeResponse.created_at),
    });
  });

  it("throws an error", async () => {
    mockSingle.mockResolvedValueOnce({
      data: null,
      error: new Error("DB error"),
    });

    await expect(createShopCode({ shopID: "999" })).rejects.toThrow(
      "Erreur lors de la cr√©ation du code de connexion"
    );
  });
});
